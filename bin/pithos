#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Kevin Mehall <km@kevinmehall.net>
#This program is free software: you can redistribute it and/or modify it 
#under the terms of the GNU General Public License version 3, as published 
#by the Free Software Foundation.
#
#This program is distributed in the hope that it will be useful, but 
#WITHOUT ANY WARRANTY; without even the implied warranties of 
#MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
#PURPOSE.  See the GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License along 
#with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk, gobject
import gst
import cgi

# Check if we are working in the source tree or from the installed 
# package and mangle the python path accordingly
if os.path.dirname(sys.argv[0]) != ".":
    if sys.argv[0][0] == "/":
        fullPath = os.path.dirname(sys.argv[0])
    else:
        fullPath = os.getcwd() + "/" + os.path.dirname(sys.argv[0])
else:
    fullPath = os.getcwd()
sys.path.insert(0, os.path.dirname(fullPath))

from pithos import AboutPithosDialog, PreferencesPithosDialog
from pithos.pithosconfig import getdatapath
from pithos.gobject_worker import GObjectWorker

class CellRendererButton(gtk.GenericCellRenderer):
    __gsignals__ = {
        'clicked': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE,
                    (gtk.TreeModel, str,))
    }

    __gproperties__ = {
        'selected': (gobject.TYPE_BOOLEAN, 'selected', 'selected', 0, gobject.PARAM_READWRITE)
    }
    
    def __init__(self, icon, selected=True):
        self.__gobject_init__()
        self.icon = icon
        self.selected = selected
        self.set_property('mode', gtk.CELL_RENDERER_MODE_ACTIVATABLE)

    def do_set_property(self, pspec, value):
        setattr(self, pspec.name, value)
    def do_get_property(self, pspec):
        return getattr(self, pspec.name)
    def on_get_size(self, widget, cell_area):
        return (0, 0, 32, 32)
    def on_render(self, window, widget, background_area, cell_area, expose_area, flags):
        if self.selected:
            state = gtk.STATE_ACTIVE
        else:
            state=gtk.STATE_INSENSITIVE
        
        if 0:
            x = cell_area.x
            y = cell_area.y+(cell_area.height-32)/2 # center vertically
            widget.style.paint_box(window, state, gtk.SHADOW_OUT, cell_area, widget, "button", x, y, 32, 32)
        
        icon = widget.style.lookup_icon_set(self.icon)
        pixbuf = icon.render_icon(widget.style, widget.get_direction(), state, gtk.ICON_SIZE_MENU, widget, detail=None)
        x = cell_area.x+(cell_area.width-pixbuf.get_width())/2 #center horizontally
        y = cell_area.y+(cell_area.height-pixbuf.get_height())/2 # center vertically     
        window.draw_pixbuf(None, pixbuf, 0, 0, x, y, width=-1, height=-1, dither=gtk.gdk.RGB_DITHER_NORMAL, x_dither=0, y_dither=0)
        
    def on_activate(self, event, widget, path, background_area, cell_area, flags):
        self.emit('clicked', widget.get_model(), path)
    

class PithosWindow(gtk.Window):
    __gtype_name__ = "PithosWindow"

    def __init__(self):
        """__init__ - This function is typically not called directly.
        Creation a PithosWindow requires redeading the associated ui
        file and parsing the ui definition extrenally,
        and then calling PithosWindow.finish_initializing().

        Use the convenience function NewPithosWindow to create
        PithosWindow object.

        """
        pass

    def finish_initializing(self, builder, pandora_class):
        """finish_initalizing should be called after parsing the ui definition
        and creating a PithosWindow object with it in order to finish
        initializing the start of the new PithosWindow instance.

        """
        #get a reference to the builder and set up the signals
        self.builder = builder
        self.builder.connect_signals(self)

        self.prefs_dlg = PreferencesPithosDialog.NewPreferencesPithosDialog()
        self.preferences = self.prefs_dlg.get_preferences()

        self.songs_model = gtk.ListStore(gobject.TYPE_PYOBJECT, str)
        self.stations_model = gtk.ListStore(gobject.TYPE_PYOBJECT, str)
        
        self.playpause_button = self.builder.get_object('playpause_button')
        self.statusbar = self.builder.get_object('statusbar1')
        
        self.songs_treeview = self.builder.get_object('songs_treeview')
        self.songs_treeview.set_model(self.songs_model)
        
        title_col   = gtk.TreeViewColumn()
        render_text = gtk.CellRendererText()
        title_col.pack_start(render_text, expand=True)
        title_col.add_attribute(render_text, "markup", 1)
        
        def rating_matches(column, cell, model, iter, user_data):
            cell.selected = (model.get_value(iter, 0).rating == user_data)
        
        render_button_up = CellRendererButton(gtk.STOCK_ABOUT)
        render_button_up.connect('clicked', self.on_rate_up)
        title_col.pack_start(render_button_up, expand=False)
        title_col.set_cell_data_func(render_button_up, rating_matches, 1)
        
        render_button_down = CellRendererButton(gtk.STOCK_CANCEL)
        render_button_down.connect('clicked', self.on_rate_down)
        title_col.pack_start(render_button_down, expand=False)
        title_col.set_cell_data_func(render_button_down, rating_matches, -1)
        
        def is_tired(column, cell, model, iter, user_data):
            cell.selected = (model.get_value(iter, 0).tired)
        
        render_button_tired = CellRendererButton(gtk.STOCK_JUMP_TO)
        render_button_tired.connect('clicked', self.on_rate_tired)
        title_col.pack_start(render_button_tired, expand=False)
        title_col.set_cell_data_func(render_button_tired, is_tired, None)
        
        render_button_info = CellRendererButton(gtk.STOCK_INFO)
        render_button_info.connect('clicked', self.on_info)
        title_col.pack_start(render_button_info, expand=False)
        
        self.songs_treeview.append_column(title_col)
        
        self.stations_combo = self.builder.get_object('stations')
        self.stations_combo.set_model(self.stations_model)
        render_text = gtk.CellRendererText()
        self.stations_combo.pack_start(render_text, expand=True)
        self.stations_combo.add_attribute(render_text, "text", 1)      
        
        self.player = gst.element_factory_make("playbin", "player")
        bus = self.player.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)
        self.time_format = gst.Format(gst.FORMAT_TIME)
        
        self.playing = False
        self.current_song_index = None
        self.current_station_index = None
        self.current_station_id = None
        self.retrying = False
        
        if not self.preferences['username']:
            self.show_preferences()
        
        self.pandora = pandora_class()
        self.worker = GObjectWorker()
        self.statusbar.push(self.statusbar.get_context_id('login'), "Logging in...")
        self.worker.send(self.pandora.connect, (self.preferences['username'], self.preferences['password']), self.pandora_ready)
    
    @property
    def current_song(self):
        if self.current_song_index is not None:
            return self.songs_model[self.current_song_index][0]
        
    @property
    def current_station(self):
        return self.stations_model[self.current_station_index][0]
    
    def song_changed(self, song_index):
        prev = self.current_song
        
        self.stop()
        self.current_song_index = song_index
        self.player.set_property("uri", self.current_song.audioUrl)
        self.play()
        
        if prev:
            self.update_song_row(prev)
            
    def next_song(self, *ignore):
        next_index = self.current_song_index+1
        self.song_changed(next_index)
        if next_index >= len(self.songs_model) -1 :
            self.get_playlist()
        
    def play(self):
        if not self.playing:
            self.playing = True
            self.player.set_state(gst.STATE_PLAYING)
            gobject.timeout_add_seconds(1, self.update_song_row)
        self.playpause_button.set_stock_id(gtk.STOCK_MEDIA_PAUSE)
        self.update_song_row()
        
    def pause(self):
        self.playing = False
        self.player.set_state(gst.STATE_PAUSED)
        self.playpause_button.set_stock_id(gtk.STOCK_MEDIA_PLAY)
        self.update_song_row()
        
    def stop(self):
        self.playing = False
        self.player.set_state(gst.STATE_NULL)
        
    def playpause(self, *ignore):
        if self.playing:
            self.pause()
        else:
            self.play()
            
    def get_playlist(self, start = False):
        def callback(l):
            start_index = len(self.songs_model)
            for i in l:
                i.index = len(self.songs_model)
                self.songs_model.append((i, ''))
                self.update_song_row(i)
            self.statusbar.pop(self.statusbar.get_context_id('playlist'))
            if start:
                self.song_changed(start_index)
            self.retrying = False
        def errback(e):
            try:
                raise e
            except PianoAuthTokenInvalid:
                self.reconnect()
            self.statusbar.pop(self.statusbar.get_context_id('playlist'))
        self.statusbar.push(self.statusbar.get_context_id('playlist'), "Getting songs...")
        self.worker.send(self.pandora.get_playlist, (self.current_station,), callback, errback)
        
    def pandora_ready(self, ignore):
        self.statusbar.pop(self.statusbar.get_context_id('login'))
        self.stations_model.clear()
        self.current_station_index = None
        index = 0
        for i in self.pandora.stations:
            i.index = len(self.stations_model)
            self.stations_model.append((i, i.name))
            if i.id == self.current_station_id:
                index = i.index
        self.station_changed(index, reconnecting = self.retrying)
        
    def reconnect(self):
        if not self.retrying:
            self.retrying = True
            self.statusbar.push(self.statusbar.get_context_id('login'), "Reconnecting...")
            self.worker.send(self.pandora.connect, (self.preferences['username'], self.preferences['password']), self.pandora_ready)
        else:
            print "Retry failed"
        
    def station_changed(self, station_index, reconnecting=False):
        if station_index is self.current_station_index: return
        if not reconnecting:
            self.current_song_index = None
            self.songs_model.clear()
            self.stop()
        self.current_station_index = station_index
        self.current_station_id = self.current_station.id
        self.get_playlist(start = not reconnecting)
        self.stations_combo.set_active(station_index)
        
        
    def on_message(self, bus, message):
        t = message.type
        if t == gst.MESSAGE_EOS:
            self.stop()
            self.next_song()
        elif t == gst.MESSAGE_ERROR:
            self.stop()
            err, debug = message.parse_error()
            print "Error: %s" % err, debug
    
    def song_text(self, song):
        title = cgi.escape(song.title)
        artist = cgi.escape(song.artist)
        album = cgi.escape(song.album)
        if song is self.current_song:
            try:
                p = ' '
                if not self.playing:
                    p = '- Paused'
                dur_int = self.player.query_duration(self.time_format, None)[0]
                dur_str = self.format_time(dur_int)
                pos_int = self.player.query_position(self.time_format, None)[0]
                pos_str = self.format_time(pos_int)
                msg = "%s / %s %s" %(pos_str, dur_str, p)
            except gst.QueryError:
                msg = ""
            return "<b><big>%s</big></b>\non <b>%s</b> by <b>%s</b>\n<small>%s</small>"%(title, album, artist, msg)
        else:
            return "<b><big>%s</big></b>\non <b>%s</b> by <b>%s</b>"%(title, album, artist)
            
    def update_song_row(self, song = None):
        if song is None:
            song = self.current_song
        if song:
            self.songs_model[song.index][1] = self.song_text(song)
        return self.playing
        
    def stations_combo_changed(self, widget):
    	index = widget.get_active()
    	if index>=0:
            self.station_changed(index)
                    
    def format_time(self, time_int):
        time_int = time_int / 1000000000
        s = time_int % 60
        time_int /= 60
        m = time_int % 60
        time_int /= 60
        h = time_int
        
        if h:
            return "%i:%02i:%021"%(h,m,s)
        else:
            return "%i:%02i"%(m,s)
            
    def on_rate_up(self, widget, model, path):
        obj = model.get_value(model.get_iter(path), 0)
        obj.rating = 1
        
    def on_rate_down(self, widget, model, path):
        obj = model.get_value(model.get_iter(path), 0)
        obj.rating = -1
        
    def on_rate_tired(self, widget, model, path):
        obj = model.get_value(model.get_iter(path), 0)
        obj.tired = True
    
    def on_info(self, widget, model, path):
        obj = model.get_value(model.get_iter(path), 0)
        print "info", obj.title

    def about(self, widget, data=None):
        """about - display the about box for pithos """
        about = AboutPithosDialog.NewAboutPithosDialog()
        response = about.run()
        about.destroy()

    def show_preferences(self, widget=None, data=None):
        """preferences - display the preferences window for pithos """
        response = self.prefs_dlg.run()
        if response == gtk.RESPONSE_OK:
            #make any updates based on changed preferences here
            pass
        self.prefs_dlg.hide()

    def quit(self, widget, data=None):
        """quit - signal handler for closing the PithosWindow"""
        self.destroy()

    def on_destroy(self, widget, data=None):
        """on_destroy - called when the PithosWindow is close. """
        #clean up code for saving application state should be added here

        gtk.main_quit()

def NewPithosWindow(pandora_class):
    """NewPithosWindow - returns a fully instantiated
    PithosWindow object. Use this function rather than
    creating a PithosWindow directly.
    """

    #look for the ui file that describes the ui
    ui_filename = os.path.join(getdatapath(), 'ui', 'PithosWindow.ui')
    if not os.path.exists(ui_filename):
        ui_filename = None

    builder = gtk.Builder()
    builder.add_from_file(ui_filename)
    window = builder.get_object("pithos_window")
    window.finish_initializing(builder, pandora_class)
    return window

if __name__ == "__main__":
    #support for command line options
    import logging, optparse
    parser = optparse.OptionParser(version="%prog %ver")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help="Show debug messages")
    parser.add_option("-t", "--test", action="store_true", dest="test", help="Use a mock web interface instead of connecting to the real Pandora server")
    (options, args) = parser.parse_args()

    #set the logging level to show debug messages
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)
        logging.debug('logging enabled')
        
    if options.test:
        from pithos.fakepiano import *
    else:
        from pithos.libpiano import *

    #run the application
    window = NewPithosWindow(PianoPandora)
    window.show()
    gtk.main()

